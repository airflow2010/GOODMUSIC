<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="{{ url_for('static', filename='script.js') }}"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <title>prism | play</title>
</head>
<body>

<div class="container">
    <div class="page-header">
        <div class="logo-wrap logo-wrap--compact">
            <img class="logo" src="{{ url_for('static', filename='prism_fullsize.png') }}" alt="Logo">
        </div>
        <select onchange="window.location.href=this.value" class="nav-select">
            <option value="{{ url_for('rating_mode') }}">rate</option>
            <option value="{{ url_for('playing_mode') }}" selected>play</option>
            <option value="{{ url_for('admin_mode') }}">admin</option>
        </select>
    </div>
    <!-- Filter Form -->
    <h2 class="section-title">filter</h2>
    <form id="playing-form" action="{{ url_for('playing_mode') }}" method="post">
        <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
        <div class="filter-form">
            <div class="filter-row filter-row-top">
                <div>
                    <label for="genre_filter">genre:</label>
                    <select id="genre_filter" name="genre_filter">
                        <option value="All" {% if filters.genre_filter == 'All' %}selected{% endif %}>All Genres</option>
                        {% for g in genres %}
                            <option value="{{ g }}" {% if g == filters.genre_filter %}selected{% endif %}>{{ g }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="slider-container">
                    <label for="min_rating_music">min_rating_music: <span id="min_rating_music_display">{{ filters.min_rating_music }}</span></label>
                    <input type="range" id="min_rating_music" name="min_rating_music" min="1" max="5" value="{{ filters.min_rating_music }}">
                </div>
                <div class="slider-container">
                    <label for="min_rating_video">min_rating_video: <span id="min_rating_video_display">{{ filters.min_rating_video }}</span></label>
                    <input type="range" id="min_rating_video" name="min_rating_video" min="1" max="5" value="{{ filters.min_rating_video }}">
                </div>
            </div>
            <div class="filter-row filter-row-bottom">
                <div class="checkbox-group">
                    <input type="checkbox" id="favorite_only" name="favorite_only" {% if filters.favorite_only %}checked{% endif %}>
                    <label for="favorite_only">favorite_only</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="include_unrated" name="include_unrated" {% if filters.include_unrated %}checked{% endif %}>
                    <label for="include_unrated">include_unrated</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="exclude_rejected" name="exclude_rejected" {% if filters.exclude_rejected %}checked{% endif %}>
                    <label for="exclude_rejected">exclude_rejected</label>
                </div>
                <div class="filter-actions">
                    <button type="submit" class="next-button">Apply</button>
                </div>
            </div>
            <div class="filter-row filter-row--single">
                <label for="selected_video_id">resulting playlist ({{ videos_count }} videos)</label>
                <div class="playlist-controls">
                    <select id="selected_video_id" name="selected_video_id" onchange="this.form.submit()" class="playlist-controls-select">
                        <option value="">-- Random / Shuffle --</option>
                        {% for v in playlist %}
                            <option value="{{ v.video_id }}" {% if video and video.video_id == v.video_id %}selected{% endif %}>
                                {{ v.artist }} - {{ v.track }}
                            </option>
                        {% endfor %}
                    </select>
                    <button type="submit" onclick="document.getElementById('selected_video_id').value='';" class="next-button button-compact">Play Next</button>
                    <button type="button" onclick="toggleExport()" class="next-button button-accent button-compact">Export</button>
                </div>
            </div>

            <div id="export-section" class="export-section is-hidden">
                <h4>Export to YouTube Playlist</h4>
                <p id="export-account">Not connected.</p>
                {% if not google_client_id %}
                    <p class="export-warning">YouTube export is disabled because GOOGLE_CLIENT_ID is not configured.</p>
                {% endif %}
                <div class="export-actions">
                    <button type="button" id="yt-connect-btn" class="save-button" {% if not google_client_id %}disabled{% endif %}>Connect YouTube</button>
                </div>
                <div id="export-controls" class="export-controls is-hidden">
                    <div class="export-field">
                        <label>Select Playlist:</label>
                        <select id="export_playlist_id">
                            <option value="">-- Create New Playlist --</option>
                        </select>
                    </div>
                    <div class="export-field">
                        <label>Or New Playlist Name:</label>
                        <input type="text" id="new_playlist_name" placeholder="My New Playlist">
                    </div>
                    <button type="button" id="yt-export-btn" class="save-button" disabled>Start Export</button>
                </div>
                <div id="export-status" class="export-status"></div>
                <p class="export-note">
                    Exports all {{ videos_count }} filtered videos. Keep this tab open during export.
                </p>
            </div>
        </div>
    </form>
    {% if index_error %}
        <div class="index-error">
            <div><strong>{{ index_error.summary }}</strong></div>
            {% if index_error.link %}
                <div><a href="{{ index_error.link }}" target="_blank" rel="noopener">Create/view index in console</a></div>
            {% endif %}
            <div class="index-error__raw">{{ index_error.raw }}</div>
        </div>
    {% endif %}

    {% if video %}

        {% if export_message %}
            <div class="export-message">{{ export_message }}</div>
        {% endif %}

        <!-- YouTube Player -->
        <div id="player-error" class="index-error is-hidden">
            <div><strong id="player-error-summary">YouTube player error</strong></div>
            <div class="index-error__raw" id="player-error-raw"></div>
        </div>
        <div class="video-container">
            <div id="player"></div>
        </div>

        <h2 class="section-title">{% if video.date_rated %}change rating of video{% else %}rate video{% endif %}</h2>
        <form id="rating-form" action="{{ url_for('save_play_rating', video_id=video.video_id) }}" method="post" class="form-grid">
            <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
            <!-- Hidden fields to preserve filters -->
            <input type="hidden" name="min_rating_music_hidden" value="{{ filters.min_rating_music }}">
            <input type="hidden" name="min_rating_video_hidden" value="{{ filters.min_rating_video }}">
            <input type="hidden" name="genre_filter_hidden" value="{{ filters.genre_filter }}">
            <input type="hidden" name="favorite_only_hidden" value="{{ 'true' if filters.favorite_only else 'false' }}">
            <input type="hidden" name="include_unrated_hidden" value="{{ 'true' if filters.include_unrated else 'false' }}">
            <input type="hidden" name="exclude_rejected_hidden" value="{{ 'true' if filters.exclude_rejected else 'false' }}">

            <!-- Ratings -->
            <div>
                <label for="rating_music">rating_music:</label>
                <select id="rating_music" name="rating_music" required class="{% if not video.date_rated %}unrated{% endif %}">
                    {% for val, desc in music_ratings.items()|sort(reverse=True) %}
                        <option value="{{ val }}" {% if val == video.rating_music %}selected{% endif %}>{{ desc }}</option>
                    {% endfor %}
                </select>
            </div>
            <div>
                <label for="rating_video">rating_video:</label>
                <select id="rating_video" name="rating_video" required class="{% if not video.date_rated %}unrated{% endif %}">
                    {% for val, desc in video_ratings.items()|sort(reverse=True) %}
                        <option value="{{ val }}" {% if val == video.rating_video %}selected{% endif %}>{{ desc }}</option>
                    {% endfor %}
                </select>
            </div>

            <!-- Genre -->
            <div>
                <label for="genre">genre:</label>
                <input type="text" id="genre" name="genre" value="{{ video.genre }}" list="genre_list" autocomplete="off">
                <datalist id="genre_list">
                    {% for g in genres %}
                        <option value="{{ g }}">
                    {% endfor %}
                </datalist>
            </div>

            <!-- Checkboxes and Save Button -->
            <div class="rating-flags-with-button">
                <div class="rating-flags">
                    <div class="checkbox-group">
                        <input type="checkbox" id="favorite" name="favorite" {% if video.favorite %}checked{% endif %}>
                        <label for="favorite">⭐ favorite</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="rejected" name="rejected" {% if video.rejected %}checked{% endif %}>
                        <label for="rejected">❌ rejected</label>
                    </div>
                </div>
                <button type="submit" class="save-button">Save</button>
            </div>
        </form>

        <div class="info">
            <p><strong>source:</strong> <a href="{{ video.source }}" target="_blank">{{ video.source }}</a></p>
            <p><strong>video_id:</strong> {{ video.video_id }}</p>
            <p><strong>date_youtube:</strong> {{ video.date_youtube }}</p>
            <p><strong>date_substack:</strong> {{ video.date_substack }}</p>
            <p><strong>date_prism:</strong> {{ video.date_prism or video.created_at }}</p>
            <p><strong>date_rated:</strong> {{ video.date_rated }}</p>
            <p><strong>genre_ai:</strong> {{ video.genre_ai }}</p>
            {% if video.genre_override %}
            <p><strong>genre_override:</strong> {{ video.genre_override }}</p>
            {% endif %}
            <p><strong>genre_ai_fidelity:</strong> {{ video.genre_ai_fidelity }}</p>
            <p><strong>genre_ai_remarks:</strong> {{ video.genre_ai_remarks }}</p>
        </div>

    {% else %}
        <h1>No videos match your filter criteria!</h1>
        <p>Try adjusting the filters above.</p>
    {% endif %}
</div>

<script>
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    var player;
    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            height: '390',
            width: '640',
            videoId: '{{ video.video_id if video else "" }}',
            playerVars: {
                'playsinline': 1,
                'autoplay': 1
            },
            events: {
                'onError': onPlayerError
            }
        });
    }

    function onPlayerError(event) {
        const playerErrorEl = document.getElementById('player-error');
        const code = event?.data;
        const videoId = '{{ video.video_id if video else "" }}' || 'N/A';
        let errorMessage = 'An unknown error occurred with the YouTube player.';

        switch (code) {
            case 2:
                errorMessage = 'The video request contains an invalid parameter value.';
                break;
            case 5:
                errorMessage = 'The requested content cannot be played in an HTML5 player or another HTML5 player error has occurred.';
                break;
            case 100:
                errorMessage = 'The video requested was not found. This occurs when a video has been removed (for any reason) or has been marked as private.';
                break;
            case 101:
            case 150:
                errorMessage = 'The owner of the requested video does not allow it to be played in embedded players.';
                break;
        }

        console.error('YouTube Player Error', { code: code, videoId: videoId, message: errorMessage, rawEvent: event });
        if (playerErrorEl) {
            playerErrorEl.classList.remove('is-hidden');
            const summaryEl = document.getElementById('player-error-summary');
            const rawEl = document.getElementById('player-error-raw');
            if (summaryEl) {
                summaryEl.textContent = 'YouTube player error';
            }
            if (rawEl) {
                rawEl.textContent = `Code: ${code} | ${errorMessage} | Video ID: ${videoId}`;
            }
        }
    }

    // Script for sliders
    document.addEventListener('DOMContentLoaded', function() {
        // Filter sliders
        const minRatingMusicSlider = document.getElementById('min_rating_music');
        const minRatingMusicDisplay = document.getElementById('min_rating_music_display');
        if (minRatingMusicSlider) {
            minRatingMusicSlider.oninput = function() { minRatingMusicDisplay.textContent = this.value; }
        }

        const minRatingVideoSlider = document.getElementById('min_rating_video');
        const minRatingVideoDisplay = document.getElementById('min_rating_video_display');
        if (minRatingVideoSlider) {
            minRatingVideoSlider.oninput = function() { minRatingVideoDisplay.textContent = this.value; }
        }

        // AJAX for rating form
        const ratingForm = document.getElementById('rating-form');
        if (ratingForm) {
            ratingForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const form = this;
                const btn = form.querySelector('.save-button');
                const originalText = btn.textContent;

                btn.textContent = 'Saving...';

                fetch(form.action, {
                    method: 'POST',
                    body: new FormData(form)
                }).then(response => {
                    if (response.ok) {
                        btn.textContent = 'Saved';
                        setTimeout(() => {
                            btn.textContent = originalText;
                        }, 1000);
                    }
                });
            });
        }
    });

    function toggleExport() {
        const sec = document.getElementById('export-section');
        if (!sec) return;
        const isHidden = sec.classList.contains('is-hidden');
        if (isHidden) {
            sec.classList.remove('is-hidden');
            loadYouTubeInfo(false);
        } else {
            sec.classList.add('is-hidden');
        }
    }

    const YT_CLIENT_ID = '{{ google_client_id or "" }}';
    const YT_SCOPES = 'https://www.googleapis.com/auth/youtube';
    let ytTokenClient = null;
    let ytAccessToken = null;
    let ytTokenExpiry = 0;
    let ytExportInProgress = false;

    function setExportStatus(message, isError = false) {
        const el = document.getElementById('export-status');
        if (!el) return;
        el.textContent = message || '';
        el.style.color = isError ? '#ff6b6b' : '#cfd8dc';
    }

    function setExportAccount(message, isError = false) {
        const el = document.getElementById('export-account');
        if (!el) return;
        el.textContent = message;
        el.style.color = isError ? '#ff6b6b' : '#cfd8dc';
    }

    function formatYouTubeError(err) {
        const message = err && err.message ? err.message : String(err || 'Unknown error');
        const normalized = message.toLowerCase();
        if (normalized.includes('channel not found') || normalized.includes('channelnotfound')) {
            return 'This Google account does not have a YouTube channel yet. Visit youtube.com to create one, then reconnect.';
        }
        return message;
    }

    function waitForGoogleOAuth(timeoutMs = 5000) {
        return new Promise((resolve, reject) => {
            const start = Date.now();
            (function check() {
                if (window.google && google.accounts && google.accounts.oauth2) {
                    resolve();
                    return;
                }
                if (Date.now() - start > timeoutMs) {
                    reject(new Error('Google OAuth client failed to load.'));
                    return;
                }
                setTimeout(check, 100);
            })();
        });
    }

    function initYouTubeTokenClient() {
        if (ytTokenClient || !YT_CLIENT_ID) return;
        ytTokenClient = google.accounts.oauth2.initTokenClient({
            client_id: YT_CLIENT_ID,
            scope: YT_SCOPES,
            callback: () => {},
            include_granted_scopes: false
        });
    }

    function tokenIsValid() {
        return ytAccessToken && Date.now() < ytTokenExpiry - 60000;
    }

    async function ensureYouTubeToken(interactive) {
        if (!YT_CLIENT_ID) {
            throw new Error('Google OAuth client is not configured.');
        }
        await waitForGoogleOAuth();
        initYouTubeTokenClient();
        if (!ytTokenClient) {
            throw new Error('Google OAuth client could not be initialized.');
        }
        if (tokenIsValid()) {
            return ytAccessToken;
        }
        return new Promise((resolve, reject) => {
            ytTokenClient.callback = (resp) => {
                if (resp && resp.access_token) {
                    ytAccessToken = resp.access_token;
                    ytTokenExpiry = Date.now() + (resp.expires_in || 3600) * 1000;
                    resolve(ytAccessToken);
                } else {
                    reject(new Error(resp && resp.error ? resp.error : 'Token request failed.'));
                }
            };
            ytTokenClient.requestAccessToken({ prompt: interactive ? 'consent' : '' });
        });
    }

    async function ytRequest(path, params = {}, method = 'GET', body = null) {
        const url = new URL(`https://www.googleapis.com/youtube/v3/${path}`);
        Object.entries(params).forEach(([key, value]) => {
            if (value !== undefined && value !== null && value !== '') {
                url.searchParams.set(key, value);
            }
        });
        const options = {
            method: method,
            headers: {
                'Authorization': `Bearer ${ytAccessToken}`,
                'Accept': 'application/json'
            }
        };
        if (body) {
            options.headers['Content-Type'] = 'application/json';
            options.body = JSON.stringify(body);
        }
        const resp = await fetch(url.toString(), options);
        const text = await resp.text();
        let data = {};
        if (text) {
            try {
                data = JSON.parse(text);
            } catch {
                data = { error: { message: text } };
            }
        }
        if (!resp.ok) {
            const message = data && data.error && data.error.message ? data.error.message : text || `HTTP ${resp.status}`;
            throw new Error(message);
        }
        return data;
    }

    async function loadYouTubeInfo(interactive) {
        const controls = document.getElementById('export-controls');
        const exportBtn = document.getElementById('yt-export-btn');
        const select = document.getElementById('export_playlist_id');

        if (!YT_CLIENT_ID) {
            setExportAccount('YouTube export is not configured.');
            return;
        }

        setExportStatus('');
        if (controls) controls.classList.add('is-hidden');
        if (exportBtn) exportBtn.disabled = true;

        try {
            if (!interactive && !tokenIsValid()) {
                setExportAccount('Not connected.');
                setExportStatus('Click "Connect YouTube" to authorize.');
                return;
            }

            setExportAccount('Connecting to YouTube...');
            await ensureYouTubeToken(interactive);

            const channelData = await ytRequest('channels', { part: 'snippet', mine: 'true' });
            const channelTitle = channelData.items && channelData.items[0] && channelData.items[0].snippet
                ? channelData.items[0].snippet.title
                : 'Unknown';
            setExportAccount(`Connected account: ${channelTitle}`);

            const playlists = [];
            let pageToken = '';
            do {
                const data = await ytRequest('playlists', {
                    part: 'snippet',
                    mine: 'true',
                    maxResults: '50',
                    pageToken: pageToken
                });
                (data.items || []).forEach(item => playlists.push(item));
                pageToken = data.nextPageToken || '';
            } while (pageToken);

            if (select) {
                select.innerHTML = '';
                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = '-- Create New Playlist --';
                select.appendChild(defaultOpt);
                playlists.forEach(pl => {
                    const opt = document.createElement('option');
                    opt.value = pl.id;
                    opt.textContent = (pl.snippet && pl.snippet.title) ? pl.snippet.title : pl.id;
                    select.appendChild(opt);
                });
            }

            if (controls) controls.classList.remove('is-hidden');
            if (exportBtn) exportBtn.disabled = false;
        } catch (err) {
            const friendly = formatYouTubeError(err);
            if (friendly.startsWith('This Google account does not have a YouTube channel')) {
                setExportAccount('YouTube channel missing.', true);
                setExportStatus(friendly, true);
            } else {
                setExportAccount('Not connected.');
                setExportStatus(`YouTube connection required: ${friendly}`, true);
            }
        }
    }

    async function connectYouTube() {
        await loadYouTubeInfo(true);
    }

    function getFilteredVideoIds() {
        const select = document.getElementById('selected_video_id');
        if (!select) return [];
        const ids = [];
        for (const option of select.options) {
            if (option.value) {
                ids.push(option.value);
            }
        }
        return Array.from(new Set(ids));
    }

    async function exportToYouTube() {
        if (ytExportInProgress) return;
        const exportBtn = document.getElementById('yt-export-btn');
        const select = document.getElementById('export_playlist_id');
        const newNameInput = document.getElementById('new_playlist_name');
        const videoIds = getFilteredVideoIds();

        if (!videoIds.length) {
            setExportStatus('No videos to export for the current filter.', true);
            return;
        }

        ytExportInProgress = true;
        if (exportBtn) exportBtn.disabled = true;
        setExportStatus(`Preparing export of ${videoIds.length} videos...`);

        try {
            await ensureYouTubeToken(true);

            const newName = newNameInput ? newNameInput.value.trim() : '';
            let playlistId = select ? select.value : '';
            if (newName) {
                const created = await ytRequest(
                    'playlists',
                    { part: 'snippet,status' },
                    'POST',
                    { snippet: { title: newName }, status: { privacyStatus: 'private' } }
                );
                playlistId = created.id;
            } else if (!playlistId) {
                throw new Error('Select a playlist or enter a new playlist name.');
            }

            const existingIds = new Set();
            if (!newName) {
                let pageToken = '';
                do {
                    const data = await ytRequest('playlistItems', {
                        part: 'snippet',
                        playlistId: playlistId,
                        maxResults: '50',
                        pageToken: pageToken
                    });
                    (data.items || []).forEach(item => {
                        const vid = item.snippet && item.snippet.resourceId ? item.snippet.resourceId.videoId : null;
                        if (vid) existingIds.add(vid);
                    });
                    pageToken = data.nextPageToken || '';
                } while (pageToken);
            }

            let added = 0;
            let skipped = 0;
            let failed = 0;

            for (let i = 0; i < videoIds.length; i += 1) {
                const vid = videoIds[i];
                if (existingIds.has(vid)) {
                    skipped += 1;
                } else {
                    try {
                        await ytRequest(
                            'playlistItems',
                            { part: 'snippet' },
                            'POST',
                            { snippet: { playlistId: playlistId, resourceId: { kind: 'youtube#video', videoId: vid } } }
                        );
                        added += 1;
                        existingIds.add(vid);
                    } catch (err) {
                        failed += 1;
                    }
                }

                if ((i + 1) % 5 === 0 || i + 1 === videoIds.length) {
                    setExportStatus(`Exporting... ${i + 1}/${videoIds.length} | added: ${added}, skipped: ${skipped}, failed: ${failed}`);
                }
            }

            setExportStatus(`Done. Added: ${added}, skipped: ${skipped}, failed: ${failed}.`);
        } catch (err) {
            const friendly = formatYouTubeError(err);
            setExportStatus(`Export failed: ${friendly}`, true);
        } finally {
            ytExportInProgress = false;
            if (exportBtn) exportBtn.disabled = false;
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        const connectBtn = document.getElementById('yt-connect-btn');
        if (connectBtn) {
            connectBtn.addEventListener('click', function() {
                connectYouTube().catch(err => {
                    setExportStatus(`YouTube connection failed: ${err.message}`, true);
                });
            });
        }
        const exportBtn = document.getElementById('yt-export-btn');
        if (exportBtn) {
            exportBtn.addEventListener('click', function() {
                exportToYouTube();
            });
        }
    });
</script>

</body>
</html>
